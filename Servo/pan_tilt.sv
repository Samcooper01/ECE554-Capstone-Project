
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module pan_tilt(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);

parameter HEX_0 = 7'b1000000;		// zero
parameter HEX_1 = 7'b1111001;		// one
parameter HEX_2 = 7'b0100100;		// two
parameter HEX_3 = 7'b0110000;		// three
parameter HEX_4 = 7'b0011001;		// four
parameter HEX_5 = 7'b0010010;		// five
parameter HEX_6 = 7'b0000010;		// six
parameter HEX_7 = 7'b1111000;		// seven
parameter HEX_8 = 7'b0000000;		// eight
parameter HEX_9 = 7'b0011000;		// nine
parameter HEX_10 = 7'b0001000;	// ten
parameter HEX_11 = 7'b0000011;	// eleven
parameter HEX_12 = 7'b1000110;	// twelve
parameter HEX_13 = 7'b0100001;	// thirteen
parameter HEX_14 = 7'b0000110;	// fourteen
parameter HEX_15 = 7'b0001110;	// fifteen
parameter OFF   = 7'b1111111;		// all off

wire pan_pwm; 
wire tilt_pwm;

logic [10:0]pan_angle;
logic [10:0]tilt_angle;

reg signed [10:0] x, x_raw, y_raw;
reg signed [9:0] y;

logic dir_sel, k1_prev, k2_prev, load;

// press button[0] to generate a low active reset signal
wire rst_n = KEY[0];

assign LEDR[0] = ~rst_n;
assign LEDR[1] = dir_sel;
assign GPIO[0] = tilt_pwm; 
assign GPIO[1] = pan_pwm;

//=======================================================
//  Structural coding
//=======================================================

// instantiate servo module here
servo SERVO_PAN(
	.clk(CLOCK_50), 
	.rst_n(rst_n),
	.pulse_width(pan_angle), 
	.pwm_pin(pan_pwm),
	.open()
);

servo SERVO_TILT(
	.clk(CLOCK_50), 
	.rst_n(rst_n),
	.pulse_width(tilt_angle), 
	.pwm_pin(tilt_pwm),
	.open()
);

//Coordinate transform module
Coordinate_transform_v2  transform(
     .x(x),.y(y),
     .clk(CLOCK_50), .rst_n(rst_n),
     .pan(pan_angle), .tilt(tilt_angle));

always_ff @(posedge CLOCK_50, negedge rst_n) begin
  if(!rst_n)begin
	k1_prev <= 1'b0;
	k2_prev <= 1'b0;
  end else begin
	k1_prev <= KEY[1];
	k2_prev <= KEY[2];
  end
end

always_ff @(posedge CLOCK_50, negedge rst_n) begin
 if(!rst_n) begin
    dir_sel <= 1'b0;
	 //load <= 1'b0;
    x_raw <= 10'd320;
    y_raw <= 10'd240;
 end else begin
    //load <= (KEY[2] & ~k2_prev);
    dir_sel <= (KEY[1] & ~k1_prev) ? ~dir_sel : dir_sel;
    x_raw <= (dir_sel) ? SW[9:0] : x_raw;
    y_raw <= (!dir_sel) ? SW[9:0] : y_raw;
  end
end

always_ff @(posedge CLOCK_50, negedge rst_n) begin
  if(!rst_n)begin
	x = 10'd320; 
	y = 10'd240;
  end else begin
	x <= (x_raw > 10'd639) ? 10'd639 : x_raw; 
	y <= (y_raw > 10'd479) ? 9'd479 : y_raw; 
  end

end


always @(*) begin
    case(SW[3:0])
      4'd0: HEX0 = HEX_0;
	   4'd1: HEX0 = HEX_1;
	   4'd2: HEX0 = HEX_2;
	   4'd3: HEX0 = HEX_3;
	   4'd4: HEX0 = HEX_4;
	   4'd5: HEX0 = HEX_5;
	   4'd6: HEX0 = HEX_6;
	   4'd7: HEX0 = HEX_7;
	   4'd8: HEX0 = HEX_8;
	   4'd9: HEX0 = HEX_9;
	   4'd10: HEX0 = HEX_10;
	   4'd11: HEX0 = HEX_11;
	   4'd12: HEX0 = HEX_12;
	   4'd13: HEX0 = HEX_13;
	   4'd14: HEX0 = HEX_14;
	   4'd15: HEX0 = HEX_15;
    endcase
end

always @(*) begin
    case(SW[7:4])
      4'd0: HEX1 = HEX_0;
	   4'd1: HEX1 = HEX_1;
	   4'd2: HEX1 = HEX_2;
	   4'd3: HEX1 = HEX_3;
	   4'd4: HEX1 = HEX_4;
	   4'd5: HEX1 = HEX_5;
	   4'd6: HEX1 = HEX_6;
	   4'd7: HEX1 = HEX_7;
	   4'd8: HEX1 = HEX_8;
	   4'd9: HEX1 = HEX_9;
	   4'd10: HEX1 = HEX_10;
	   4'd11: HEX1 = HEX_11;
	   4'd12: HEX1 = HEX_12;
	   4'd13: HEX1 = HEX_13;
	   4'd14: HEX1 = HEX_14;
	   4'd15: HEX1 = HEX_15;
    endcase
end

always @(*) begin
    case(SW[9:8])
      4'd0: HEX2 = HEX_0;
	   4'd1: HEX2 = HEX_1;
	   4'd2: HEX2 = HEX_2;
	   4'd3: HEX2 = HEX_3;
    endcase
	 HEX3 = OFF;
	 HEX4 = OFF;
	 HEX5 = OFF;
end

endmodule
